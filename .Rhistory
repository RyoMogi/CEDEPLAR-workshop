if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
return(outcome)
}
## For country 1
lf_c <- widelxpx(data = data_c)
lf_c
data_c
# Period data
SWE_p <- read.table("Data/SWEpft.txt", header = T, fill = T, skip = 2)
USA_p <- read.table("Data/USApft.txt", header = T, fill = T, skip = 2)
# Cohort data
SWE_c <- read.table("Data/SWEcft.txt", header = T, fill = T, skip = 2)
USA_c <- read.table("Data/USAcft.txt", header = T, fill = T, skip = 2)
# target life table function: lx or px
target <- lxpx
## Function to create a matrix of lx or px
widelxpx <- function(data){
px <- data %>%
as.data.frame() %>%
#filter(Cohort >= Y1) %>% # select year from the same year
filter(x %out% over50) %>%              # select age (12- to 49)
mutate(q1x = as.numeric(as.character(q1x)),
px = 1 - q1x) %>%
select(Cohort, x, px)
# create a matrix of px
px_wide <- px %>%
mutate(px = ifelse(x %in% c("12-", "13", "14", "15") & is.na(px), 1, px)) %>%
spread(key = Cohort, value = px) %>%
select(-x) %>%
as.matrix()
lx_wide <- matrix(NA, ncol = ncol(px_wide), nrow = nrow(px_wide))
lx_wide[1, ] <- 1
for(i in 1:(nrow(lx_wide)-1)){
lx_wide[i+1, ] <- lx_wide[i, ] * px_wide[i, ]
}
colnames(lx_wide) <- colnames(px_wide)
if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
return(outcome)
}
## For country 1
lf_c <- widelxpx(data = data_c)
lf_c
data_c
View(data_c)
data = data_c
# Cohort data
SWE_c <- read.table("Data/SWEcft.txt", header = T, fill = T, skip = 2)
USA_c <- read.table("Data/USAcft.txt", header = T, fill = T, skip = 2)
data_c <- SWE_c
data = data_c
px <- data %>%
as.data.frame() %>%
#filter(Cohort >= Y1) %>% # select year from the same year
filter(x %out% over50) %>%              # select age (12- to 49)
mutate(q1x = as.numeric(as.character(q1x)),
px = 1 - q1x) %>%
select(Cohort, x, px)
# create a matrix of px
px_wide <- px %>%
mutate(px = ifelse(x %in% c("12-", "13", "14", "15") & is.na(px), 1, px)) %>%
spread(key = Cohort, value = px) %>%
select(-x) %>%
as.matrix()
lx_wide <- matrix(NA, ncol = ncol(px_wide), nrow = nrow(px_wide))
lx_wide[1, ] <- 1
for(i in 1:(nrow(lx_wide)-1)){
lx_wide[i+1, ] <- lx_wide[i, ] * px_wide[i, ]
}
colnames(lx_wide) <- colnames(px_wide)
if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
outcome
## Function to create a matrix of lx or px
widelxpx <- function(data){
px <- data %>%
as.data.frame() %>%
#filter(Cohort >= Y1) %>% # select year from the same year
filter(x %out% over50) %>%              # select age (12- to 49)
mutate(q1x = as.numeric(as.character(q1x)),
px = 1 - q1x) %>%
select(Cohort, x, px)
# create a matrix of px
px_wide <- px %>%
mutate(px = ifelse(x %in% c("12-", "13", "14", "15") & is.na(px), 1, px)) %>%
spread(key = Cohort, value = px) %>%
select(-x) %>%
as.matrix()
lx_wide <- matrix(NA, ncol = ncol(px_wide), nrow = nrow(px_wide))
lx_wide[1, ] <- 1
for(i in 1:(nrow(lx_wide)-1)){
lx_wide[i+1, ] <- lx_wide[i, ] * px_wide[i, ]
}
colnames(lx_wide) <- colnames(px_wide)
if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
return(outcome)
}
## For country 1
lf_c <- widelxpx(data = data_c)
lf_c
if(any(colnames(lf_c) == "1966")){
lf_1966 <- lf_c[, "1966"]
} else {
lf_1966 <- NA
}
## the position of the maximum completed birth cohort
if(length(lf_1966[!is.na(lf_1966)]) == 38){
min1 <- which(colnames(lf_c) == "1966")
lf_c <- lf_c[, min1:ncol(lf_c)]
# extract data in a triangle format
lf_triangle <- c()
for(k in 1:ncol(lf_c)){
lf_triangle <- cbind(lf_triangle, c(lf_c[1:(38 - k + 1), k], rep(NA, k - 1)))
}
colnames(lf_triangle) <- colnames(lf_c)
} else {
min1 <- lf_c[nrow(lf_c), ]
min1 <- length(min1[!is.na(min1)])
## select data from the maximum completed birth cohort
lf_triangle <- lf_c[, min1:ncol(lf_c)]
}
# create Age:Year matrix contains lx or px
data_select <- function(Pdata, lf_c){
startY <- as.numeric(as.character(colnames(lf_c)))[ncol(lf_c)] + 12
lastBC <- lf_c[, ncol(lf_c)]
endY   <- startY + length(lastBC[!is.na(lastBC)]) - 1
px_wide <- Pdata %>%
as.data.frame() %>%
filter(x %out% over50) %>%
mutate(q1x = as.numeric(as.character(q1x)),
px = 1 - q1x) %>%
select(Year, x, px) %>%
filter(Year >= startY & Year <= endY) %>%
spread(key = Year, value = px) %>%
select(-x) %>%
as.matrix()
lx_wide <- matrix(NA, ncol = ncol(px_wide), nrow = nrow(px_wide))
lx_wide[1, ] <- 1
for(i in 1:(nrow(lx_wide)-1)){
lx_wide[i+1, ] <- lx_wide[i, ] * px_wide[i, ]
}
colnames(lx_wide) <- colnames(px_wide)
if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
return(outcome)
}
## Data from country A using period fertility table
data_p <- data_select(Pdata = data_p, lf_c = lf_triangle)
# make new data strage: hypthetical cohort
period2cohort <- function(data){
n <- ncol(data)
bc <- c()
for(i in 2:n){
row <- c()
row <- c(data[i, - c(1:(i - 1))], rep(NA, i-1))
bc  <- rbind(bc, row)
}
bc <- rbind(data[1,], bc)
years <- as.numeric(as.character(colnames(bc)))
colnames(bc) <- years - 12
rownames(bc) <- NULL
return(bc)
}
data_hypbc <- period2cohort(data = data_p)
## combine cohort data and hypothetical data
data_hypbc <- rbind(data_hypbc, matrix(NA, dim(lf_triangle)[1] - dim(data_hypbc)[1], ncol(data_hypbc)))
out_lf_c <- cbind(lf_triangle, data_hypbc[, -1])
out_lf_c
# decomposition ----------------------------------------------------------------
# create a diagonal matrix for CALC choosing lx or px
lxpx <- function(data_c, data_p, lxpx){
# target life table function: lx or px
target <- lxpx
## Function to create a matrix of lx or px
widelxpx <- function(data){
px <- data %>%
as.data.frame() %>%
#filter(Cohort >= Y1) %>% # select year from the same year
filter(x %out% over50) %>%              # select age (12- to 49)
mutate(q1x = as.numeric(as.character(q1x)),
px = 1 - q1x) %>%
select(Cohort, x, px)
# create a matrix of px
px_wide <- px %>%
mutate(px = ifelse(x %in% c("12-", "13", "14", "15") & is.na(px), 1, px)) %>%
spread(key = Cohort, value = px) %>%
select(-x) %>%
as.matrix()
lx_wide <- matrix(NA, ncol = ncol(px_wide), nrow = nrow(px_wide))
lx_wide[1, ] <- 1
for(i in 1:(nrow(lx_wide)-1)){
lx_wide[i+1, ] <- lx_wide[i, ] * px_wide[i, ]
}
colnames(lx_wide) <- colnames(px_wide)
if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
return(outcome)
}
## For country 1
lf_c <- widelxpx(data = data_c)
if(any(colnames(lf_c) == "1966")){
lf_1966 <- lf_c[, "1966"]
} else {
lf_1966 <- NA
}
## the position of the maximum completed birth cohort
if(length(lf_1966[!is.na(lf_1966)]) == 38){
min1 <- which(colnames(lf_c) == "1966")
lf_c <- lf_c[, min1:ncol(lf_c)]
# extract data in a triangle format
lf_triangle <- c()
for(k in 1:ncol(lf_c)){
lf_triangle <- cbind(lf_triangle, c(lf_c[1:(38 - k + 1), k], rep(NA, k - 1)))
}
colnames(lf_triangle) <- colnames(lf_c)
} else {
min1 <- lf_c[nrow(lf_c), ]
min1 <- length(min1[!is.na(min1)])
## select data from the maximum completed birth cohort
lf_triangle <- lf_c[, min1:ncol(lf_c)]
}
### Prepare period data to create hypothetical data
# create Age:Year matrix contains lx or px
data_select <- function(Pdata, lf_c){
startY <- as.numeric(as.character(colnames(lf_c)))[ncol(lf_c)] + 12
lastBC <- lf_c[, ncol(lf_c)]
endY   <- startY + length(lastBC[!is.na(lastBC)]) - 1
px_wide <- Pdata %>%
as.data.frame() %>%
filter(x %out% over50) %>%
mutate(q1x = as.numeric(as.character(q1x)),
px = 1 - q1x) %>%
select(Year, x, px) %>%
filter(Year >= startY & Year <= endY) %>%
spread(key = Year, value = px) %>%
select(-x) %>%
as.matrix()
lx_wide <- matrix(NA, ncol = ncol(px_wide), nrow = nrow(px_wide))
lx_wide[1, ] <- 1
for(i in 1:(nrow(lx_wide)-1)){
lx_wide[i+1, ] <- lx_wide[i, ] * px_wide[i, ]
}
colnames(lx_wide) <- colnames(px_wide)
if(target == "lx"){
outcome <- lx_wide
} else {
outcome <- px_wide
}
return(outcome)
}
## Data from country A using period fertility table
data_p <- data_select(Pdata = data_p, lf_c = lf_triangle)
# make new data strage: hypthetical cohort
period2cohort <- function(data){
n <- ncol(data)
bc <- c()
for(i in 2:n){
row <- c()
row <- c(data[i, - c(1:(i - 1))], rep(NA, i-1))
bc  <- rbind(bc, row)
}
bc <- rbind(data[1,], bc)
years <- as.numeric(as.character(colnames(bc)))
colnames(bc) <- years - 12
rownames(bc) <- NULL
return(bc)
}
data_hypbc <- period2cohort(data = data_p)
## combine cohort data and hypothetical data
data_hypbc <- rbind(data_hypbc, matrix(NA, dim(lf_triangle)[1] - dim(data_hypbc)[1], ncol(data_hypbc)))
out_lf_c <- cbind(lf_triangle, data_hypbc[, -1])
return(out_lf_c)
}
px1 <- lxpx(Names = Names[1], lxpx = "px")
Names <- c("USA", "SWE")
Names2 <- c("The US", "Sweden")
px1 <- lxpx(Names = Names[1], lxpx = "px")
px1 <- lxpx(data_c = USA_c, data_p = USA_p, lxpx = "px")
px2 <- lxpx(data_c = SWE_c, data_p = SWE_p, lxpx = "px")
## The correct assignment of contributions and the cummulative changes
CALlxD  <- matrix(NA, 38, 38)
CALlxDS <- CALlxD
Age <- c(12:49)
BC <- 1966:2003
for (y in 1:38){
for (x in 1:y){
CALlxD[x, (38 - y + x)]  <- CALlxDecompBC[x, y]
CALlxDS[x, (38 - y + x)] <- sum(CALlxDecompBC[(1:x), y])
}
}
# calculate CALC and decomposition
CALCDecompFunction  <- function(px1, px2, lxLx, Name1, Name2){
CALClx  <- c()
CALClx1 <- c()
CALClx2 <- c()
PxCh   <- c()
PxCh <- log(px2 / px1)
PxCh <- ifelse(is.na(PxCh), 0, PxCh)
colnames(PxCh) <- rownames(PxCh) <- NULL
# change the order: 1st column (the youngest cohort) -> the last column (the oldest cohort)
PxCh <- PxCh[, ncol(PxCh):1]
px2CALlx <- function(px){
# px matrix to lx
lx <- apply(px, 2, cumprod)
lx <- rbind(rep(1, ncol(px)), lx)
# lx to CAL lx
CALlx <- c()
for(i in 1:ncol(px)){
order <- 38:1
CALlx[i] <- lx[order[i], i]
}
CALlx <- rev(CALlx)
return(CALlx)
}
CALClx1 <- px2CALlx(px1)
CALClx2 <- px2CALlx(px2)
#CALClx1 <- apply(px1, 2, prod, na.rm = T)
#CALClx2 <- apply(px2, 2, prod, na.rm = T)
CALClx_mid <- t(matrix(rep((CALClx1 + CALClx2)/2, 38), length(CALClx1)))
# calculate CALC
CALC <- function(lx, type){
# CALC using lx
CALC_lx <- sum(lx[-1]) + 0.5
# CALC using Lx
Lx <- (lx[1:37] + lx[2:38]) / 2
Lx <- c(Lx, lx[38])
CALC_Lx <- sum(Lx)
out <- ifelse(type == "lx", CALC_lx, CALC_Lx)
return(out)
}
# final output
A1 <- CALC(lx = CALClx1, type = lxLx)
A2 <- CALC(lx = CALClx2, type = lxLx)
A3 <- A2 - A1
A4 <- sum(PxCh * CALClx_mid)
print(rbind(c(paste("CALC-", Name1), paste("CALC-", Name2), "Diff", "est-Diff"), round(c(A1, A2, A3, A4), 2)))
return(PxCh * CALClx_mid)
}
## The correct assignment of contributions and the cummulative changes
CALlxD  <- matrix(NA, 38, 38)
CALlxDS <- CALlxD
Age <- c(12:49)
BC <- 1966:2003
for (y in 1:38){
for (x in 1:y){
CALlxD[x, (38 - y + x)]  <- CALlxDecompBC[x, y]
CALlxDS[x, (38 - y + x)] <- sum(CALlxDecompBC[(1:x), y])
}
}
## The correct assignment of contributions and the cummulative changes
CALlxDecompBC <- CALCDecompFunction(px1, px2, "Lx", Names[1], Names[2])
CALlxD  <- matrix(NA, 38, 38)
CALlxDS <- CALlxD
Age <- c(12:49)
BC <- 1966:2003
for (y in 1:38){
for (x in 1:y){
CALlxD[x, (38 - y + x)]  <- CALlxDecompBC[x, y]
CALlxDS[x, (38 - y + x)] <- sum(CALlxDecompBC[(1:x), y])
}
}
# +12 = the period of CALC
colnames(px1)[ncol(px1)]
tab_contr <- CALlxDecompBC
# table: contribution of each age and cohort
for(i in 1:ncol(CALlxDecompBC)){
tab_contr[, 1 + ncol(CALlxDecompBC) - i] <- round(CALlxDecompBC[, i], 4)
}
colnames(tab_contr) <- BC
rownames(tab_contr) <- Age
# calculate all cohort
all_contr <- rev(tab_contr_cumsum[nrow(tab_contr_cumsum), ])
sum_all_contr <- cumsum(all_contr)
filled.contour(BC, Age, t(CALlxDS), levels = levels,
col = WildColors, key.axes = customAxis(),
ylab = "", xlab = "", cex.lab = 1.1,
plot.axes = {axis(1, at = c(1966, seq(1970, 2000, by = 5), 2003),
labels = c("", "1970\n(1982)", "1975\n(1987)", "1980\n(1992)",
"1985\n(1997)", "1990\n(2002)", "1995\n(2007)",
"2000\n(2012)", "2003\n(2015)"), hadj = 0.6, padj = 0.5, cex.axis = 0.9)
axis(2, at = seq(15, 50, by = 5), labels = seq(15, 50, by = 5))})
filled.contour(BC, Age, t(CALlxDS), levels = levels,
col = decomp_palette, key.axes = customAxis(),
ylab = "", xlab = "", cex.lab = 1.1,
plot.axes = {axis(1, at = c(1966, seq(1970, 2000, by = 5), 2003),
labels = c("", "1970\n(1982)", "1975\n(1987)", "1980\n(1992)",
"1985\n(1997)", "1990\n(2002)", "1995\n(2007)",
"2000\n(2012)", "2003\n(2015)"), hadj = 0.6, padj = 0.5, cex.axis = 0.9)
axis(2, at = seq(15, 50, by = 5), labels = seq(15, 50, by = 5))})
CALlxDS
BC
Age
levels
filled.contour(BC, Age, t(CALlxDS))
decomp_palette
mypalette  <- rev(brewer.pal(8, "YlGnBu"))
library(RColorBrewer)
mypalette  <- rev(brewer.pal(8, "YlGnBu"))
mypalette2 <- rev(brewer.pal(8, "YlOrRd"))
decomp_palette <- c(mypalette[1:4], "white", "white", mypalette2[c(6, 4, 2, 1)])
filled.contour(BC, Age, t(CALlxDS), levels = levels,
col = decomp_palette, key.axes = customAxis(),
ylab = "", xlab = "", cex.lab = 1.1,
plot.axes = {axis(1, at = c(1966, seq(1970, 2000, by = 5), 2003),
labels = c("", "1970\n(1982)", "1975\n(1987)", "1980\n(1992)",
"1985\n(1997)", "1990\n(2002)", "1995\n(2007)",
"2000\n(2012)", "2003\n(2015)"), hadj = 0.6, padj = 0.5, cex.axis = 0.9)
axis(2, at = seq(15, 50, by = 5), labels = seq(15, 50, by = 5))})
filled.contour(BC, Age, t(CALlxDS), levels = levels)
levels <- c(-1, -0.1, -0.01, -0.001, -0.0001, 0, .0001, .001, .01, .1, 1)
customAxis <- function() {
n <- length(levels)
y <- seq(min(levels), max(levels), length.out = n)
rect(0, y[1:(n-1)], 1, y[2:n], col = decomp_palette)
axis(4, at = y, labels = levels)
}
filled.contour(BC, Age, t(CALlxDS), levels = levels,
col = decomp_palette, key.axes = customAxis(),
ylab = "", xlab = "", cex.lab = 1.1,
plot.axes = {axis(1, at = c(1966, seq(1970, 2000, by = 5), 2003),
labels = c("", "1970\n(1982)", "1975\n(1987)", "1980\n(1992)",
"1985\n(1997)", "1990\n(2002)", "1995\n(2007)",
"2000\n(2012)", "2003\n(2015)"), hadj = 0.6, padj = 0.5, cex.axis = 0.9)
axis(2, at = seq(15, 50, by = 5), labels = seq(15, 50, by = 5))})
mypalette  <- rev(brewer.pal(8, "YlGnBu"))
mypalette2 <- rev(brewer.pal(8, "YlOrRd"))
decomp_palette <- c(mypalette[1:4], "white", "white", mypalette2[c(6, 4, 2, 1)])
levels <- c(-1, -0.1, -0.01, -0.001, -0.0001, 0, .0001, .001, .01, .1, 1)
customAxis <- function() {
n <- length(levels)
y <- seq(min(levels), max(levels), length.out = n)
rect(0, y[1:(n-1)], 1, y[2:n], col = decomp_palette)
axis(4, at = y, labels = levels)
}
filled.contour(BC, Age, t(CALlxDS), levels = levels,
col = decomp_palette, key.axes = customAxis(),
ylab = "", xlab = "", cex.lab = 1.1,
plot.axes = {axis(1, at = c(1966, seq(1970, 2000, by = 5), 2003),
labels = c("", "1970\n(1982)", "1975\n(1987)", "1980\n(1992)",
"1985\n(1997)", "1990\n(2002)", "1995\n(2007)",
"2000\n(2012)", "2003\n(2015)"), hadj = 0.6, padj = 0.5, cex.axis = 0.9)
axis(2, at = seq(15, 50, by = 5), labels = seq(15, 50, by = 5))})
options(scipen = 10)
Nm <- paste("out/Fig", Names[2], "-", Names[1], "_bc.pdf", sep = "")
pdf(Nm)
par(cex.axis = 1)
par(oma = c(1, 0, 0, 0)) #bottom, right, top, left
filled.contour(BC, Age, t(CALlxDS), levels = levels,
col = decomp_palette, key.axes = customAxis(),
ylab = "", xlab = "", cex.lab = 1.1,
plot.axes = {axis(1, at = c(1966, seq(1970, 2000, by = 5), 2003),
labels = c("", "1970\n(1982)", "1975\n(1987)", "1980\n(1992)",
"1985\n(1997)", "1990\n(2002)", "1995\n(2007)",
"2000\n(2012)", "2003\n(2015)"), hadj = 0.6, padj = 0.5, cex.axis = 0.9)
axis(2, at = seq(15, 50, by = 5), labels = seq(15, 50, by = 5))})
title(ylab = "Cumulative Age and Cohort Contribution", font.lab = 2)
mtext("Birth Cohort\n(Year)", 1, line = 4.5, adj = 0.4, font = 2) # adj: (-)left-right(+), line: (+)down-up(-)
mtext(Names2[2], 3, 0.5, adj = 0.9, cex = 0.9)
mtext(Names2[1], 1, 0.5, adj = 0.9, cex = 0.9)
dev.off()
method <- "Lx"
SWE_px <- lxpx(data_c = SWE_c, data_p = SWE_p, lxpx = "px")
SWE_calc <- CALCFunc(SWE_px, method)
# CALC -------------------------------------------------------------------------
fun_CALC <- function(px, lxLx){
# px matrix to lx
lx <- apply(px, 2, cumprod)
lx <- rbind(rep(1, ncol(px)), lx)
# lx to CAL lx
CALlx <- c()
for(i in 1:ncol(px)){
order <- 38:1
CALlx[i] <- lx[order[i], i]
}
#CALlx <- apply(px, 2, prod, na.rm = T)
CALlx <- rev(CALlx)
# CAL lx to CAL Lx
CALLx <- (CALlx[1:37] + CALlx[2:38]) * 0.5
CALLx <- c(CALLx, CALlx[38])
# CALC
if(lxLx == "Lx"){
CALC <- round(sum(CALLx), 2)
} else {
CALC <- round(0.5 + sum(CALlx[-1]), 2)
}
return(CALC)
}
SWE_calc <- fun_CALC(SWE_px, method)
SWE_calc
USA_px <- lxpx(data_c = USA_c, data_p = USA_p, lxpx = "px")
USA_calc <- fun_CALC(USA_px, method)
USA_calc
